
setwd('~/Dropbox/lbt/st-vin/mcrs/')
load("data/brenton2018.RData", verbose = TRUE)



library(tibble)
library(dplyr)
library(purrr)
library(binom)



get_m_ijk <- function(dat, index, imperfect, resolver) {

  return(table(
    dat[[resolver]], dat[[index]], dat[[imperfect]], 
    useNA='no'
  )) # indices: [k, i, j]

}

get_s_st_ij <- function(dat, index, imperfect, resolver) {

  dat_miss <- dat[is.na(dat[[resolver]]), ]
  return(table(
    dat_miss[[imperfect]], dat_miss[[index]]
  )) # s^*_ij, indices: [j, i]

}




two_dim_col_wise_prop <- function(x) {
  denom <- colSums(x)
  K <- length(denom)
  no_denom <- which(denom == 0)
  if (length(no_denom) > 0) {
    x[, no_denom] <- diag(K)[, no_denom]
    denom[no_denom] <- 1
  }
  return(x / rep(denom, each=K))
}




get_p_ijk <- function(m_ijk) {

  p_ijk <- apply(m_ijk, 3, two_dim_col_wise_prop)
  dim(p_ijk) <- dim(m_ijk)
  return(p_ijk)

}


sim_mstar <- function(p_ijk, s_st_ij) {

  m_st_ijk <- p_ijk # array(0, dim = dim(m_ijk))
  K <- dim(p_ijk)[1]
  
  for (i in 1:K) for (j in 1:K) 
    m_st_ijk[, i, j] <- rmultinom(n = 1, size = s_st_ij[j, i], prob = p_ijk[, i, j])

  return(m_st_ijk)
}

get_m_st_ik <- function(p_ijk, s_st_ij) {

  m_st_ijk <- sim_mstar(p_ijk, s_st_ij)

  m_st_ik <- apply(m_st_ijk, 1:2, sum)

  return(m_st_ik)

}


get_m_ik <- function(m_ijk) {

  m_ik <- apply(m_ijk, 1:2, sum)

  return(m_ik)

}


get_c_ik <- function(m_ik, m_st_ik) {

  return(m_st_ik + m_ik)

}

rep_as_list <- function(x, n) {
  return(list(x)[rep(1,n)])
}


get_sens_spec <- function(tab, pos, alpha = 0.05) {

  spec_rws <- !(rownames(tab) %in% as.character(pos))
  sens_rws <-   rownames(tab) %in% as.character(pos)

  data_frame(
    param = c("sens", "spec"),
    cases = as.integer(c(sum(tab[sens_rws, ]), sum(tab[spec_rws, ]))),
    correct = as.integer(c(sum(tab[sens_rws, sens_rws]), sum(tab[spec_rws, spec_rws]))),
    est = correct / cases,
    lo = binom.confint(correct, cases, conf.level = 1-alpha, methods = "wilson")$lower,
    up = binom.confint(correct, cases, conf.level = 1-alpha, methods = "wilson")$upper
  )
}






# get_c_ik(df)

perform_mrcs <- 
  function(
    dat, 
    index, imperfect, resolver,
    pos,
    r = 1000,
    seed = 12345678,
    alpha = 0.05,
    summ = TRUE
  ) {

  m_ijk   <-   get_m_ijk(dat, index, imperfect, resolver) # indices: [k, i, j]
  s_st_ij <- get_s_st_ij(dat, index, imperfect, resolver) # s^*_ij, indices: [j, i]

  # create a list of the constant 3D array of probabilities, indices: [k, i, j]
  get_p_ijk <- get_p_ijk(m_ijk)
  # create a list of the constant 2D array of resamples, indices: [k, i]
  m_ik <- get_m_ik(m_ijk)
  
  # now randomly generate the unobserved m_st_ik values r-times
  # create a list (length r) 2D arrays of different m_st_ik, indices: [k, i]
  set.seed(seed) # make reproducible
  msl <- replicate(r, get_m_st_ik(get_p_ijk, s_st_ij), simplify = FALSE)
  
  # create a list (length r) 2D arrays of different c_ik, indices: [k, i]
  cl  <- map(msl, ~get_c_ik(m_ik, .))
  
  # calculate summary stats for each c_ik in list
  # concatenate each returned data_frame row-wise
  ss  <- map_dfr(cl, ~get_sens_spec(., pos = pos, alpha = alpha))

  if(summ) { # just return mean est, and relevant quantiles of CIs
    ss_summ <- 
      ss %>% 
      group_by(param) %>% 
      summarise(
        est = mean(est), 
        lo=quantile(lo, alpha/2), 
        up=quantile(up, 1-alpha/2)
      )
    return(ss_summ)
  } else {
    return(ss)
  }

}

system.time(perform_mrcs(brenton2018, "A", "S", "P", pos = 3:4, r = 1000))

brenton2018


# the sens+spec estimates using the imperfect truth
get_sens_spec(table(brenton2018[["S"]], brenton2018[["A"]]), 3:4)
## A tibble: 2 x 6
##   param cases correct   est    lo    up
##   <chr> <int>   <int> <dbl> <dbl> <dbl>
## 1 sens    449     423 0.942 0.917 0.960
## 2 spec    432     342 0.792 0.751 0.827

# now check against mCRS (allow ~0.02 sec per repetition)
perform_mrcs(brenton2018, "A", "S", "P", pos = 3:4, r = 1000)
## A tibble: 2 x 4
##   param   est    lo    up
##   <chr> <dbl> <dbl> <dbl>
## 1 sens  0.932 0.894 0.958
## 2 spec  0.901 0.851 0.939

# turn the 4 categories into 2, to see how estimates change
brenton0 <- brenton2018 %>% 
  mutate(
    A = ifelse(A %in% 1:2, 1L, 2L),
    S = ifelse(S %in% 1:2, 1L, 2L),
    P = ifelse(is.na(P), NA, ifelse(P %in% 1:2, 1L, 2L)) # handle NA cases
  )

get_sens_spec(table(brenton0[["S"]], brenton0[["A"]]), 2) # same as before
# mCRS where K=2 (allow ~0.02 sec per repetition)
perform_mrcs(brenton0, "A", "S", "P", pos = 2, r = 1000) 
## A tibble: 2 x 4
##   param   est    lo    up
##   <chr> <dbl> <dbl> <dbl>
## 1 sens  0.919 0.877 0.950
## 2 spec  0.877 0.821 0.921



