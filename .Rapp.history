setwd('~/Dropbox/lbt/st-vin/mcrs/')#
load("data/brenton2018.RData", verbose = TRUE)#
library(tibble)#
library(dplyr)#
library(purrr)#
library(binom)#
get_m_ijk <- function(dat, index, imperfect, resolver) {#
#
  return(table(#
    dat[[resolver]], dat[[index]], dat[[imperfect]], #
    useNA='no'#
  )) # indices: [k, i, j]#
#
}#
#
get_s_st_ij <- function(dat, index, imperfect, resolver) {#
#
  dat_miss <- dat[is.na(dat[[resolver]]), ]#
  return(table(#
    dat_miss[[imperfect]], dat_miss[[index]]#
  )) # s^*_ij, indices: [j, i]#
#
}#
two_dim_col_wise_prop <- function(x) {#
  denom <- colSums(x)#
  K <- length(denom)#
  no_denom <- which(denom == 0)#
  if (length(no_denom) > 0) {#
    x[, no_denom] <- diag(K)[, no_denom]#
    denom[no_denom] <- 1#
  }#
  return(x / rep(denom, each=K))#
}#
get_p_ijk <- function(m_ijk) {#
#
  p_ijk <- apply(m_ijk, 3, two_dim_col_wise_prop)#
  dim(p_ijk) <- dim(m_ijk)#
  return(p_ijk)#
#
}#
sim_mstar <- function(p_ijk, s_st_ij) {#
#
  m_st_ijk <- p_ijk # array(0, dim = dim(m_ijk))#
  K <- dim(p_ijk)[1]#
  for (i in 1:K) for (j in 1:K) #
    m_st_ijk[, i, j] <- rmultinom(n = 1, size = s_st_ij[j, i], prob = p_ijk[, i, j])#
#
  return(m_st_ijk)#
}#
#
get_m_st_ik <- function(p_ijk, s_st_ij) {#
#
  m_st_ijk <- sim_mstar(p_ijk, s_st_ij)#
#
  m_st_ik <- apply(m_st_ijk, 1:2, sum)#
#
  return(m_st_ik)#
#
}#
get_m_ik <- function(m_ijk) {#
#
  m_ik <- apply(m_ijk, 1:2, sum)#
#
  return(m_ik)#
#
}#
get_c_ik <- function(m_ik, m_st_ik) {#
#
  return(m_st_ik + m_ik)#
#
}#
#
rep_as_list <- function(x, n) {#
  return(list(x)[rep(1,n)])#
}#
get_sens_spec <- function(tab, pos, alpha = 0.05) {#
#
  spec_rws <- !(rownames(tab) %in% as.character(pos))#
  sens_rws <-   rownames(tab) %in% as.character(pos)#
#
  data_frame(#
    param = c("sens", "spec"),#
    cases = as.integer(c(sum(tab[sens_rws, ]), sum(tab[spec_rws, ]))),#
    correct = as.integer(c(sum(tab[sens_rws, sens_rws]), sum(tab[spec_rws, spec_rws]))),#
    est = correct / cases,#
    lo = binom.confint(correct, cases, conf.level = 1-alpha, methods = "wilson")$lower,#
    up = binom.confint(correct, cases, conf.level = 1-alpha, methods = "wilson")$upper#
  )#
}#
# get_c_ik(df)#
#
perform_mrcs <- #
  function(#
    dat, #
    index, imperfect, resolver,#
    pos,#
    r = 1000,#
    seed = 12345678,#
    alpha = 0.05,#
    summ = TRUE#
  ) {#
#
  m_ijk   <-   get_m_ijk(dat, index, imperfect, resolver) # indices: [k, i, j]#
  s_st_ij <- get_s_st_ij(dat, index, imperfect, resolver) # s^*_ij, indices: [j, i]#
#
  # create a list of the constant 3D array of probabilities, indices: [k, i, j]#
#   pl  <- rep_as_list(get_p_ijk(m_ijk), r)#
  p <- get_p_ijk(m_ijk)#
  # create a list of the constant 2D array of out-of-resamples, indices: [j, i]#
#   ssl <- rep_as_list(s_st_ij,         r)#
  # create a list of the constant 2D array of resamples, indices: [k, i]#
#   ml  <- rep_as_list(get_m_ik(m_ijk), r)#
  m_ik <- get_m_ik(m_ijk)#
  # now randomly generate the unobserved m_st_ik values r-times#
  # create a list (length r) 2D arrays of different m_st_ik, indices: [k, i]#
  set.seed(seed) # make reproducible#
  msl <- replicate(r, get_m_st_ik(p, s_st_ij), simplify = FALSE)#
#
#   msl <- map2(pl, ssl, ~get_m_st_ik(.x, .y))#
  # create a list (length r) 2D arrays of different c_ik, indices: [k, i]#
  cl  <- map(msl, ~get_c_ik(m_ik, .))#
  # calculate summary stats for each c_ik in list#
  # concatenate each returned data_frame row-wise#
  ss  <- map_dfr(cl, ~get_sens_spec(., pos = pos, alpha = alpha))#
#
  if(summ) { # just return mean est, and relevant quantiles of CIs#
    ss_summ <- #
      ss %>% #
      group_by(param) %>% #
      summarise(#
        est = mean(est), #
        lo=quantile(lo, alpha/2), #
        up=quantile(up, 1-alpha/2)#
      )#
    return(ss_summ)#
  } else {#
    return(ss)#
  }#
#
}#
#
system.time(perform_mrcs(brenton2018, "A", "S", "P", pos = 3:4, r = 1000))#
#
brenton2018#
# the sens+spec estimates using the imperfect truth#
get_sens_spec(table(brenton2018[["S"]], brenton2018[["A"]]), 3:4)#
## A tibble: 2 x 6#
##   param cases correct   est    lo    up#
##   <chr> <int>   <int> <dbl> <dbl> <dbl>#
## 1 sens    449     423 0.942 0.917 0.960#
## 2 spec    432     342 0.792 0.751 0.827#
#
# now check against mCRS (allow ~0.02 sec per repetition)#
perform_mrcs(brenton2018, "A", "S", "P", pos = 3:4, r = 1000)#
## A tibble: 2 x 4#
##   param   est    lo    up
brenton0 <- brenton2018 %>% #
  mutate(#
    A = ifelse(A %in% 1:2, 1L, 2L),#
    S = ifelse(S %in% 1:2, 1L, 2L),#
    P = ifelse(is.na(P), NA, ifelse(P %in% 1:2, 1L, 2L)) # handle NA cases#
  )
get_sens_spec(table(brenton0[["S"]], brenton0[["A"]]), 2) # same as before
perform_mrcs(brenton0, "A", "S", "P", pos = 2, r = 1000)
